from __future__ import annotations
from typing import Protocol, List, Callable, runtime_checkable
from .datadomain import Peer, Prefs, ServiceStatus, SystemState

"""Public contract between GUI widgets and the data backend.

This file contains **no runtime logic** – only type definitions so that the
widgets can be fully type‑checked without importing heavy DBus code.
"""



# Generic callback signature for observer pattern
Callback = Callable[[], None]

@runtime_checkable
class DataProvider(Protocol):
    # ────────────── read‑only ──────────────
    def get_peers(self) -> List[Peer]: ...
    def get_prefs(self) -> Prefs: ...
    def get_status(self) -> ServiceStatus: ...
    def our_latest_descriptors(self) -> str: ...
    def get_system_state(self) -> SystemState: ...  # optional (debug)

    # ────────────── peer ops ──────────────
    def rename_peer(self, peer_id: str, new_name: str) -> None: ...
    def delete_peer(self, peer_id: str) -> None: ...
    def verify_and_pin_peer(self, peer_id: str, hostname: str) -> None: ...
    def peer_addr_add(self, peer_id: str, ip: str) -> None: ...
    def peer_addr_del(self, peer_id: str, ip: str) -> None: ...

    # ───────────── preference ops ──────────
    def set_pref(self, key: str, value: str | bool | int) -> None: ...
    def add_pref(self, key: str, value: str) -> None: ...
    def remove_pref(self, key: str, value: str) -> None: ...

    # ───────────── observer API ────────────
    def subscribe(self, event: str, callback: Callback) -> None: ...
    # valid events: "peers_changed", "prefs_changed", "status_changed"