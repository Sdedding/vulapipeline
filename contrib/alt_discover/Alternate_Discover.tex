\documentclass[a4paper,11pt]{report}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage{hyperref}
\hypersetup{pdfborder=0 0 0}


\title{Vula Alternate Discovery}
\author{Nicolo Lüscher, Yannick Stebler}

\begin{document}

\maketitle
\tableofcontents

\chapter{Introduction}
Vula currently discovers peers by broadcasting its own descriptor over mDNS. 
If mDNS is blocked by default on a network, Vula has no way to automatically discover other peers. This branch provides a new, covert way to discover other peers by sending the descriptor as part of the normal ARP traffic over the network. This allows Vula to automatically discover new peers and is more difficult to block than mDNS. This document contains information about the new features and an analysis of the attack surface. 

\chapter{General Considerations}
The Vula Alternate Discovery project provides an alternative to mDNS. It provides an alternative way to connect to new peers automatically and without additional python dependencies. In this alternative discovery protocol, the Vula descriptor is broadcast over the network hidden in ARP packets.
The project consists of two parts. The Alternate Discovery Publish and the Alternate Discovery Discover which are described in the following subsections:
\section{Alternate Discovery Publish (sender)}
The publish daemon fetches the current Vula descriptors from the ´vula organize´ daemon over D-Bus, or it uses a descriptor passed in optionally as a command line argument.
The descriptor is then compressed, encrypted, and then split into small chunks of data that are inserted into the padding area of ARP packets. These packets are then transmitted over the network on a frequent basis for other peers to discover
\section{Alternate Discovery Discover (receiver)}
The discover daemon looks for ARP packets which contain possible encrypted data as sent by other Vula peers. The discovery daemon uses a raw socket and explicitly only looks at packets that have an ARP header. When the discover daemon receives a candidate packet it attempts a trial decryption process. The use of Authenticated Encryption with Associated Data (AEAD) allows the discovery program to know if a decryption was successful. If it was successful, the plaintext is treated as a possible Vula descriptor and passed to ´vula organize´ for processing.
\section{Dependencies}
The Discovery Alternate project does not use any additional dependencies that are not part of the python standard library. Thus, no new elements have been added to the code base.
\section{Licensing}
According to the GNU project (https://www.gnu.org/licenses/
license-list.html) the MIT license (Expat license) is compatible with
the GNU General Public License (GNU GPL), under which the Vula project is li-
is licensed.
The fact that no additional libraries were used means that we are quite free to use Vula and therefore also the Alternate Discovery project.
\chapter{Security Considerations}
The alternative discovery implementation compresses a vula descriptor with zlib and then it encrypts it with nacl. The encryption is only meant to obfuscate, and it is not intended to provide long term confidentiality. It is trivial to recover the plain text payload by design. The encryption key is generated by taking the sending Vula peer's MAC address and hashing it with sha256.
The encryption key could be mixed with a user supplied password, and then it should be hashed with a password hashing function such as ´argon2´. A design and an analysis would be required to add a password as the current design is only meant to defeat a trivial network sniffer with limited capabilities.
The publish and discover daemons implementations use raw sockets. We reduce available privileges for the daemons by using systemd and only allow the required capabilities for using raw sockets.
\section{Considered Attack Vectors}
Alternate discovery can be used to send arbitrary descriptors to a Vula device. These descriptors are however not verified and have the same state as the ones sent by the traditional discovery method. It thus does not open another attack vector. By obfuscating and segmenting the data into multiple packets, the protocol could be considered more secure than the traditional mDNS discovery protocol, but we make no additional security claims. The packets are intended to be indistinguishable from normal ARP traffic other than by the use of non-zero padding. The frequency of the packets is likely an additional fingerprint vector as normal ARP traffic does not usually generate 20 ARP requests or 20 ARP replies in such a short period of time. he protocol should be harder to censor than mDNS as it does not use the Multicast Ethernet address as a destination by an adversary who has enabled filtering of that Multicast Ethernet address. The protocol uses FF:FF:FF:FF:FF:FF and does not change the usual length of ARP packets.
\newpage
\section{Threat modeling and mitigations}
Vula itself only provides protection against an active attacker if the peer is verified. Vula alternate Discovery takes a descriptor, sends it across the network, and then adds it as a peer at another endpoint. 
Therefore, we consider possible attacks on the receiver side of Vula alternate Discovery: 
\begin{enumerate}
    \item Deep packet inspection automated by router / switch / firewall
    \item Manipulate the program function by sending a possible exploit to take control of the raw socket 
    \item ARP packet inspections to read possible descriptors and connect to the peer itself
\end{enumerate}
Network switching equipment may include the ability to censor mDNS on the local network, and it usually does not provide a way to censor packets with full packet content filtering. We take advantage of this limited capability to hide within ARP packets, and by using the Ethernet broadcast address. An adversary could use ´tcpdump´ or another more expensive Deep Packet Inspection (DPI) tool for detection of the alternative publish and discovery packets. We consider the DPI adversary to be out of scope and focus on bypassing mDNS censorship performed with network switch access control lists (ACLs) based on destination Ethernet addresses.
\newline
\newline
To counter the first point, the descriptors were given some sort of encryption. This encryption, which uses the MAC address of the sender as the key, is not used to encrypt the data securely, but rather as a way to obfuscate data such that it is not transmitted in plain text. This has the advantage that a check of the ARP packets by a router / firewall / switch can no longer lead to the fact that this detects the Alternate Discovery Packets and can thus block.
This stops trivial checking of ARP packets with simple string matching. The use of ´FF:FF:FF:FF:FF:FF´ stops the filtering of known Multicast addresses. These two choices together ensure that an adversary must perform trial decryption and/or filter all ARP packets which do not have zero padding.
\newline
\newline
To mitigate the second point, the rights of the two parts running as a service were limited to a minimum. Descriptors are only processed if they are valid.
\newline
\newline
Currently, we do not stop arbitrary parties from running the discovery program to discover known peers. An adversary could do this and write a program to instruct a switch to disable a Vula peer's switch port. The use of a shared secret such as a password could thwart confirmation of a trivially decryptable ciphertext, but we have not specified or implemented a method of including a password.
\chapter{Protocol}
The publish daemon sends its Vula descriptor over the network. It does this by transmitting multiple ARP requests for a random IP address it gets from its ARP cache. The padding (or trailer) of this request is replaced with a subset of the ciphertext. The number of packets depends on the length of the ciphertext. The ciphertext is constructed by compressing a Vula descriptor, and encrypting it with nacl.

The discovery daemon listens for incoming ARP traffic and searches for packets with non-zero padding. If it detects such a packet it then creates a set of packets coming from that source. After each packet, the discovery daemon attempts trial decryption. If it successfully decrypts a ciphertext, it treats the result as a possible Vula descriptor and sends it to ´vula organize´ for processing.

\chapter{Proposed Solution}
Both the sender and the receiver are running as systemd processes that aren't enabled by default. To enable them, run ´sudo systemctl start vula-publish-alt.service´ or ´sudo systemctl start vula-discover-alt.service´ respectively. The programs then can be controlled over their respective dbus interfaces.

\subsubsection{local.vula.discoveralt} can be used to control the discovery process. Use the \textbf{start} method without any arguments to initiate the discovery process. The service will listen for incoming traffic and automatically insert the received desriptors into Vula.


\subsubsection{local.vula.publishalt} can be used to control the publishing process. The \textbf{start} method accepts an array of IP addresses as strings (eg. "192.168.1.1"). Those IP addresses represent the interfaces that the process publishes on.
If the "eth0" interface for example has the IP address "192.168.1.4", you would pass '["192.168.1.4"]' as an argument to the start method. 
It will then publish the descriptor associated with this IP every 90 seconds to the network that "eth0" is connected to.

\end{document}
